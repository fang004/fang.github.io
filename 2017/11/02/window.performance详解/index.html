<!-- build time:Fri Nov 03 2017 17:27:24 GMT+0800 (CST) --><!DOCTYPE html><html><head><meta charset="UTF-8"><title>window.performance详解 | 赵芳</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/styles.css"><link rel="shortcut icon" href="/2017/11/02/window.performance详解/index.html"></head></html><body class="te-body-default"><div class="te-wrap" id="teWrap"><div class="te-left"><div id="menu-outer"><div id="menu-inner"><div class="te-menu-item"><a href="/"><span>赵芳</span></a></div><div class="te-menu-item"><a href="/archives"><span>所有文章</span></a></div><div class="te-menu-item"><a href="https://github.com/fang004"><span>Github</span></a></div></div></div></div><div class="te-right"><div id="content-outer"><div id="content-inner"><article id="post"><h1 class="post-title">window.performance详解</h1><div class="toc-show" id="tocShow"></div><div class="te-post-outer"><div class="te-post-inner"><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h2 id="扒一扒演变"><a href="#扒一扒演变" class="headerlink" title="扒一扒演变"></a>扒一扒演变</h2><ul><li>在没有<code>performance</code>标准的时候，通过各种方式监控性能，麻烦且测量指标单一。<ul><li>控制台工具、<code>Fiddler</code>抓包工具</li><li>使用<code>DOMContentLoaded</code>和<code>document.onreadystatechange</code>这种侵入式<code>javascript</code>代码方式来检测DOM事件发生和结束的时间</li><li>使用第三方工具如<code>WebPagetest</code>、<code>Pingdom</code>等通过在不同的浏览器环境和地域进行测试来寻求优化建议等等</li></ul></li><li><code>W3C</code>与浏览器厂商逐渐意识到性能对于<code>web</code>开发的重要性，<code>W3C</code>推出了一套性能<code>API</code>标准。</li><li><p>下图是标准在规范流程中的进展</p><p><img src="https://raw.githubusercontent.com/fang004/attachment/master/blog/img/2017102005.png" alt="标准在规范流程中的进展"></p></li><li><p>能<code>API</code>标准目的：简化开发者对网站性能进行采集、分析的过程，方便开发者采取手段提高<code>web</code>性能</p></li><li>整套标准包含了10多种<code>API</code>，各自针对性能检测的某个方面。</li></ul><h3 id="API及描述其功能的列表"><a href="#API及描述其功能的列表" class="headerlink" title="API及描述其功能的列表"></a><code>API</code>及描述其功能的列表</h3><table><thead><tr><th>API</th><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>Navigation Timing</td><td>导航计时</td><td>能够帮助网站开发者检测真实用户数据（RUM），例如带宽、延迟或主页的整体页面加载时间。</td></tr><tr><td>Resource Timing</td><td>资源计时</td><td>对单个资源的计时，可以对细粒度的用户体验进行检测。</td></tr><tr><td>High Resolution Timing</td><td>高精度计时</td><td>该API规范所定义的JavaScript接口能够提供精确到微秒级的当前时间，并且不会受到系统时钟偏差或调整的影响。</td></tr><tr><td>Page Visibility</td><td>页面可见性</td><td>通过这一规范，网站开发者能够以编程方式确定页面的当前可见状态，从而使网站能够更有效地利用电源与CPU。当页面获得或失去焦点时，文档对象的visibilitychange事件便会被触发。</td></tr><tr><td>Performance Timeline</td><td>性能时间线</td><td>以一个统一的接口获取由Navigation Timing、Resourcing Timing和User Timing所收集的性能数据。</td></tr><tr><td>Battery Status</td><td>电池状态</td><td>能够检测当前设备的电池状态，例如是否正在充电、电量等级。可以根据当前电量决定是否显示某些内容，对于移动设备来说非常实用。</td></tr><tr><td>User Timing</td><td>用户计时</td><td>可以对某段代码、函数进行自定义计时，以了解这段代码的具体运行时间。</td></tr><tr><td>Beacon</td><td>灯塔</td><td>可以将分析结果或诊断代码发送给服务器，它采用了异步执行的方式，因此不会影响页面中其它代码的运行。</td></tr><tr><td>Animation Timing</td><td>动画计时</td><td>通过requestAnimationFrame函数让浏览器精通地控制动画的帧数，能够有效地配合显示器的刷新率，提供更平滑的动画效果，减少对CPU和电池的消耗。</td></tr><tr><td>Resource Hits</td><td>资源提示</td><td>通过html属性指定资源的预加载，例如在浏览相册时能够预先加载下一张图片，加快翻页的显示速度。</td></tr><tr><td>Frame Timing</td><td>帧计时</td><td>通过一个接口获取与帧相关的性能数据，例如每秒帧数和TTF。</td></tr><tr><td>Navigation Error Logging</td><td>错误日志记录</td><td>通过一个接口存储及获取与某个文档相关的错误记录。</td></tr></tbody></table><h3 id="浏览器支持列表"><a href="#浏览器支持列表" class="headerlink" title="浏览器支持列表"></a>浏览器支持列表</h3><table><thead><tr><th>规范</th><th>IE</th><th>Firefox</th><th>Chrome</th><th>Safari</th><th>Opera</th><th>iOS Safari</th><th>Android</th></tr></thead><tbody><tr><td>Navigation Timing</td><td>9</td><td>31</td><td>全部</td><td>8</td><td>26</td><td>8 (不包括 8.1)</td><td>4.1</td></tr><tr><td>High Resolution Timing</td><td>10</td><td>31</td><td>全部</td><td>8</td><td>26</td><td>8 (不包括 8.1)</td><td>4.4</td></tr><tr><td>Page Visibility</td><td>10</td><td>31</td><td>全部</td><td>7</td><td>26</td><td>7.1</td><td>4.4</td></tr><tr><td>Resource Timing</td><td>10</td><td>34</td><td>全部</td><td>-</td><td>26</td><td>-</td><td>4.4</td></tr><tr><td>Battery Status*</td><td>-</td><td>31（部分支持）</td><td>38</td><td>-</td><td>26</td><td>-</td><td>-</td></tr><tr><td>User Timing</td><td>10</td><td>-</td><td>全部</td><td>-</td><td>26</td><td>-</td><td>4.4</td></tr><tr><td>Beacon</td><td>-</td><td>31</td><td>39</td><td>-</td><td>26</td><td>-</td><td>-</td></tr><tr><td>Animation Timing</td><td>10</td><td>31</td><td>全部</td><td>6.1</td><td>26</td><td>7.1</td><td>4.4</td></tr><tr><td>Resource Hints</td><td>-</td><td>-</td><td>仅限Canary版</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>Frame Timing</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>Navigation Error Logging</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>WebP*</td><td>-</td><td>-</td><td>全部</td><td>-</td><td>26</td><td>-</td><td>4.1</td></tr><tr><td>Picture element and srcset attribute *</td><td>-</td><td>-</td><td>38</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="performance的作用"><a href="#performance的作用" class="headerlink" title="performance的作用"></a><code>performance</code>的作用</h2><p>浏览器暴露给js的一个接口，可以通过这个接口查看用户访问网站的连接建立时间、dns时间等信息。使用该api时需要在页面完全加载完成之后才能使用，最简单的办法是在<code>window.onload</code>事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。<br><code>performance</code> 接口会给出某个页面的与时间相关的性能信息。</p><h2 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h2><p><img src="https://raw.githubusercontent.com/fang004/attachment/master/blog/img/2017102001.png" alt="兼容性"></p><h1 id="各个值详解"><a href="#各个值详解" class="headerlink" title="各个值详解"></a>各个值详解</h1><p><img src="https://raw.githubusercontent.com/fang004/attachment/master/blog/img/2017102002.png" alt="api接口"></p><ul><li><code>memory</code>浏览器内存情况<ul><li><code>jsHeapSizeLimit</code>内存大小限制</li><li><code>totalJSHeapSize</code>当前js堆栈内存总大小</li><li><code>usedJSHeapSize</code>JS 对象（包括V8引擎内部对象）占用的内存，一定小于<code>totalJSHeapSize</code><ul><li>注：<code>usedJSHeapSize</code>大于<code>totalJSHeapSize</code>时，有可能出现了内存泄露</li></ul></li></ul></li><li><code>navigation</code>网页导航相关<ul><li><code>redirectCount</code>重定向属性，当前页面是几次重定向才过来的。（有同源策略限制，仅能检测同源的重定向）</li><li><code>type</code>通过什么方式进入的页面<ul><li><code>0</code>(<code>TYPE_NAVIGATENEXT</code>)常规导航方式访问页面，如点一个链接、一般的get方式</li><li><code>1</code>(<code>TYPE_RELOAD</code>)通用刷新（包括<code>js</code>调用刷新接口等方式）访问页面</li><li><code>2</code>(<code>TYPE_BACK_FORWARD</code>)通过后退按钮访问本页面</li><li><code>255</code>(<code>TYPE_UNDEFINED</code>)非以上方式进入的页面</li></ul></li></ul></li><li><code>timing</code>测速相关<ul><li><img src="https://raw.githubusercontent.com/fang004/attachment/master/blog/img/2017102003.png" alt="浏览器访问各阶段概览"></li><li>各个值详解<ul><li><code>navigationStart</code>准备加载的开始时间。<ul><li>在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）<code>unload</code> 的时间戳，如果无前一个网页 <code>unload</code> ，则与 <code>fetchStart</code> 值相等</li></ul></li><li><code>unloadEventStart</code> 前一个网页（与当前页面同域）<code>unload</code> 的时间戳<ul><li>如果无前一个网页 <code>unload</code> 或者前一个网页与当前页面不同域，则值为 0</li></ul></li><li><code>unloadEventEnd</code>返回前一个网页 <code>unload</code> 事件绑定的回调函数执行完毕的时间戳<ul><li>对应<code>unloadEventStart</code>执行完毕的时间</li></ul></li><li><code>redirectStart</code>重定向发生时的时间。<ul><li>如果发生了<code>HTTP</code>重定向，并且从导航开始，中间的每次重定向，都和当前文档同域的话，就返回开始重定向的<code>timing.fetchStart</code>的值。其他情况，则返回0</li></ul></li><li><code>redirectEnd</code>重定向完成时的时间。<ul><li>对应<code>redirectStart</code>最后一次重定向，接收到最后一个字节数据后的时间。</li></ul></li><li><code>fetchStart</code>浏览器准备好使用 <code>HTTP</code> 请求抓取文档的时间，这发生在检查本地缓存之前<ul><li>如果一个新的资源获取被发起，则 <code>fetchStart</code>必须返回用户代理开始检查其相关缓存的那个时间，其他情况则返回开始获取该资源的时间</li></ul></li><li><code>domainLookupStart``DNS</code> 域名查询开始的时间<ul><li>用户代理对当前文档所属域进行DNS查询开始的时间。如果此请求没有<code>DNS</code>查询过程，如长连接，资源<code>cache</code>,甚至是本地资源等。 那么就返回 <code>fetchStart</code>的值</li></ul></li><li><code>domainLookupEnd</code> <code>DNS</code> 域名查询完成的时间<ul><li>对应<code>domainLookupStart</code>的完成时间，如果此请求没有<code>DNS</code>查询过程，如长连接，资源<code>cache</code>,甚至是本地资源等。 那么就返回 <code>fetchStart</code>的值</li></ul></li><li><code>connectStart</code> <code>HTTP</code>（<code>TCP</code>）开始建立连接的时间<ul><li>用户代理向服务器服务器请求文档，开始建立连接的那个时间，如果此连接是一个长连接，又或者直接从缓存中获取资源（即没有与服务器建立连接）。则返回<code>domainLookupEnd</code>的值.</li><li>如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间</li></ul></li><li>(<code>secureConnectionStart</code>)可选特性。 <code>HTTPS</code> 连接开始的时间<ul><li>用户代理如果没有对应的东东，就要把这个设置为<code>undefined</code>。如果有这个东东，并且是<code>HTTPS</code>协议，那么就要返回开始<code>SSL</code>握手的那个时间。 如果不是<code>HTTPS</code>， 那么就返回0</li></ul></li><li><code>connectEnd``HTTP</code>（<code>TCP</code>）完成建立连接的时间<ul><li>对应<code>connectStart</code>的完成时间，如果此连接是一个长连接，又或者直接从缓存中获取资源（即没有与服务器建立连接）。则返回<code>domainLookupEnd</code>的值</li><li>如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间</li><li>这里握手结束，包括安全连接建立完成、SOCKS 授权通过</li></ul></li><li><code>requestStart</code>开始请求文档的时间<ul><li>从服务器、缓存、本地资源等，开始请求文档的时间</li><li>连接错误重连时，这里显示的也是新建立连接的时间</li></ul></li><li><code>responseStart</code> 开始接收响应的开始时间<ul><li>用户代理从服务器、缓存、本地资源中，接收到第一个字节数据的时间</li></ul></li><li><code>responseEnd</code>响应全部接收完的时间<ul><li>对应<code>responseStart</code>（接收最后一个字符、当前连接被关闭）的时间中，更早的那个。同样，文档可能来自服务器、缓存、或本地资源</li></ul></li><li><code>domLoading</code> 开始解析渲染 <code>DOM</code> 树的时间<ul><li>用户代理把其文档的 <code>current document readiness</code> 设置为 <code>loading</code>的时间。</li></ul></li><li><code>domInteractive</code>完成解析 <code>DOM</code> 树的时间<ul><li>对应<code>domLoading``domComplete</code>，设置为<code>interactive</code>的时间，这时候并没有开始加载网页内的资源</li></ul></li><li><code>domContentLoadedEventStart</code> <code>DOM</code> 解析完成后，网页内资源加载开始的时间<ul><li>文档发生 <code>DOMContentLoaded</code> 事件的时间</li></ul></li><li><code>domContentLoadedEventEnd</code> <code>DOM</code> 解析完成后，网页内资源加载完成的时间（如 <code>JS</code> 脚本加载执行完毕）<ul><li>对应 <code>domContentLoadedEventStart</code>的结束时间</li></ul></li><li><code>domComplete</code> <code>DOM</code> 树解析完成，且资源也准备就绪的时间<ul><li>对应<code>domLoading``domInteractive</code> 设置为 <code>complete</code>的时间</li></ul></li><li><code>loadEventStart``load</code>回调函数开始执行的时间<ul><li>文档触发<code>load</code>事件的时间。如果<code>load</code>事件没有触发，那么该接口就返回0</li></ul></li><li><code>loadEventEnd</code> <code>load</code>事件的回调函数执行完毕的时间<ul><li>对应<code>loadEventStart</code>结束后的时间</li></ul></li></ul></li><li>组合值的意义<ul><li>重定向耗时 ：<code>redirectEnd</code> - <code>redirectStart</code><ul><li>拒绝重定向！比如，<code>http://example.com/</code> 就不该写成 <code>http://example.com</code></li></ul></li><li><code>DNS</code>查询耗时 ：<code>domainLookupEnd</code> - <code>domainLookupStart</code><ul><li><code>DNS</code> 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？</li><li>可使用 <code>HTML5 Prefetch</code> 预查询 <code>DNS</code> ，见：<a href="http://segmentfault.com/a/1190000000633364" target="_blank" rel="external">HTML5 prefetch</a></li></ul></li><li><code>TCP</code>链接耗时 ：<code>connectEnd</code> - <code>connectStart</code></li><li><code>request</code>请求耗时 ：<code>responseEnd</code> - <code>responseStart</code><ul><li>页面内容经过 <code>gzip</code> 压缩了么，静态资源 <code>css</code>/<code>js</code> 等压缩了么？</li></ul></li><li>解析<code>dom</code>树耗时 ： <code>domComplete</code> - <code>domInteractive</code><ul><li>反省下你的 DOM 树嵌套是不是太多了！</li></ul></li><li>白屏时间 ：<code>responseStart</code> - <code>navigationStart</code><ul><li><code>TTFB</code>(Time To First Byte)时间，这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？</li></ul></li><li><code>domready</code>时间 ：<code>domContentLoadedEventEnd</code> - <code>navigationStart</code></li><li>执行<code>onload</code>回调函数的时间 ：<code>loadEventEnd</code> - <code>loadEventStart</code><ul><li>是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？</li></ul></li><li><code>onload</code>时间 ：<code>loadEventEnd</code> - <code>navigationStart</code><ul><li>这几乎代表了用户等待页面可用的时间</li></ul></li><li><code>DNS</code>缓存时间 ：<code>domainLookupStart</code> - <code>fetchStart</code></li><li>卸载页面的时间 ：<code>unloadEventEnd</code> - <code>unloadEventStart</code></li><li><code>TCP</code> 建立连接完成握手的时间：<code>connectEnd</code> - <code>connectStart</code></li></ul></li></ul></li></ul><h1 id="performance方法"><a href="#performance方法" class="headerlink" title="performance方法"></a><code>performance</code>方法</h1><h2 id="performance-getEntries-资源测速"><a href="#performance-getEntries-资源测速" class="headerlink" title="performance.getEntries() 资源测速"></a><code>performance.getEntries()</code> 资源测速</h2><p><img src="https://raw.githubusercontent.com/fang004/attachment/master/blog/img/2017102004.png" alt="performance.getEntries"></p><pre><code>- 图中`type`为`link`的`css`，整个加载时间为`duration`ms;
</code></pre><ul><li>遍历这个接口统计整个页面<code>img</code>、<code>css</code>、<code>js</code>等对应的下载时间信息</li><li>组合值的意义<ul><li><code>url</code> ： name;</li><li>资源类型： entryType;</li><li>请求类型 ： initiatorType;</li><li>资源耗时 ： duration;</li><li>重定向耗时： <code>redirectEnd</code> - <code>redirectStart</code>;</li><li><code>DNS</code>查询耗时： <code>domainLookupEnd</code> - <code>domainLookupStart</code>;</li><li>内容加载完成耗时 ： <code>responseEnd</code> - <code>requestStart</code>;</li><li><code>TCP</code>完成握手耗时 ： <code>connectEnd</code> - <code>connectStart</code>;<h2 id="performance-now-精确计算程序执行时间"><a href="#performance-now-精确计算程序执行时间" class="headerlink" title="performance.now() 精确计算程序执行时间"></a><code>performance.now()</code> 精确计算程序执行时间</h2>|区别| Date.now() | performance.now() |<br>|———|————-|——————-|<br>|单位|毫秒|微秒（百万分之一秒|<br>|精确|受系统程序执行阻塞| 以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整） |<br>|输出|UNIX 时间，即距离 1970 的时间| 相对<code>performance.timing.navigationStart</code>(页面初始化) 的时间 |<h2 id="performance-mark-标记各种时间戳"><a href="#performance-mark-标记各种时间戳" class="headerlink" title="performance.mark() 标记各种时间戳"></a><code>performance.mark()</code> 标记各种时间戳</h2></li></ul></li><li>使用 performance.mark() 标记各种时间戳（就像在地图上打点），保存为各种测量值（测量地图上的点之间的距离），便可以批量地分析这些数据了。</li></ul><pre><code>    function randomFunc (n) {  
        if (!n) {
            // 生成一个随机数
            n = ~~(Math.random() * 10000);
        }
        var nameStart = &#39;markStart&#39; + n; 
        var nameEnd   = &#39;markEnd&#39; + n; 
        // 函数执行前做个标记
        window.performance.mark(nameStart);

        for (var i = 0; i &lt; n; i++) {
            // do nothing
        }

        // 函数执行后再做个标记
        window.performance.mark(nameEnd);

        // 然后测量这个两个标记间的时间距离，并保存起来
        var name = &#39;measureRandomFunc&#39; + n;
        window.performance.measure(name, nameStart, nameEnd);
    }

    // 执行三次看看
    randomFunc();  
    randomFunc();  
    // 指定一个名字
    randomFunc(888);


    // 看下保存起来的标记 mark
    var marks = window.performance.getEntriesByType(&#39;mark&#39;);  
    console.log(marks);
    // 看下保存起来的测量 measure
    var measure = window.performance.getEntriesByType(&#39;measure&#39;);  
    console.log(measure);
    // 看下我们自定义的测量
    var entries = window.performance.getEntriesByName(&#39;measureRandomFunc888&#39;);  
    console.log(entries);


    // 清除指定标记
    window.performance.clearMarks(&#39;markStart888&#39;);  
    // 清除所有标记
    window.performance.clearMarks();

    // 清除指定测量
    window.performance.clearMeasures(&#39;measureRandomFunc&#39;);  
    // 清除所有测量
    window.performance.clearMeasures();



    // 计算 domReady 时间
    var t = performance.timing  
    var domReadyTime = t.domComplete - t.responseEnd;  
    console.log(domReadyTime)


    // 其实就可以写成
    window.performance.measure(&#39;domReady&#39;,&#39;responseEnd&#39; , &#39;domComplete&#39;);  
    var domReadyMeasure = window.performance.getEntriesByName(&#39;domReady&#39;);  
    console.log(domReadyMeasure);
</code></pre><p>参考链接</p><ul><li><a href="https://w3c.github.io/navigation-timing/" target="_blank" rel="external">w3官方Navigation Timing</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming" target="_blank" rel="external">MSDN的Navigation Timing文档</a></li><li><a href="http://www.alloyteam.com/2015/09/explore-performance/" target="_blank" rel="external">初探 performance – 监控网页与程序性能</a></li><li><a href="https://segmentfault.com/a/1190000004010453" target="_blank" rel="external">使用性能API快速分析web前端性能</a></li><li><a href="https://github.com/fredshare/blog/issues/5" target="_blank" rel="external">https://github.com/fredshare/blog/issues/5</a></li></ul></div><div class="post-toc" id="postToc"><div class="toc-outer"><div class="top-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概览"><span class="toc-number">1.</span> <span class="toc-text">概览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#扒一扒演变"><span class="toc-number">1.1.</span> <span class="toc-text">扒一扒演变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API及描述其功能的列表"><span class="toc-number">1.1.1.</span> <span class="toc-text">API及描述其功能的列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器支持列表"><span class="toc-number">1.1.2.</span> <span class="toc-text">浏览器支持列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#performance的作用"><span class="toc-number">1.2.</span> <span class="toc-text">performance的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器支持情况"><span class="toc-number">1.3.</span> <span class="toc-text">浏览器支持情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#各个值详解"><span class="toc-number">2.</span> <span class="toc-text">各个值详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#performance方法"><span class="toc-number">3.</span> <span class="toc-text">performance方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#performance-getEntries-资源测速"><span class="toc-number">3.1.</span> <span class="toc-text">performance.getEntries() 资源测速</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#performance-now-精确计算程序执行时间"><span class="toc-number">3.2.</span> <span class="toc-text">performance.now() 精确计算程序执行时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#performance-mark-标记各种时间戳"><span class="toc-number">3.3.</span> <span class="toc-text">performance.mark() 标记各种时间戳</span></a></li></ol></li></ol></div></div></div></article><nav id="pagination"><a href="/2017/11/03/二维码的生成和扫码/" class="prev"><i class="fa fa-angle-left"></i></a></nav></div></div><script src="/js/scripts.js"></script></div></div><script src="/js/scripts.js"></script></body><!-- rebuild by neat -->