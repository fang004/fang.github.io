<!-- build time:Sat Sep 28 2019 02:34:18 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><title>http缓存的攻与防 | 赵芳</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/styles.css"><link rel="shortcut icon" href="/2018/08/03/http缓存的攻与防/index.html"></head></html><body class="te-body-default"><div class="te-wrap" id="teWrap"><div class="te-left"><div id="menu-outer"><div id="menu-inner"><div class="te-menu-item"><a href="/"><span>赵芳</span></a></div><div class="te-menu-item"><a href="/archives"><span>所有文章</span></a></div><div class="te-menu-item"><a href="https://github.com/fang004"><span>Github</span></a></div></div></div></div><div class="te-right"><div id="content-outer"><div id="content-inner"><article id="post"><h1 class="post-title">http缓存的攻与防</h1><div class="toc-show" id="tocShow"><i class="fa fa-navicon"></i></div><a class="go-top" href="#teWrap" id="goTop"><i class="fa fa-arrow-up"></i></a><div class="te-post-outer"><div class="te-post-inner"><h1 id="http缓存的攻与防"><a href="#http缓存的攻与防" class="headerlink" title="http缓存的攻与防"></a>http缓存的攻与防</h1><h2 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h2><h3 id="几种表现"><a href="#几种表现" class="headerlink" title="几种表现"></a>几种表现</h3><h4 id="浏览器截图"><a href="#浏览器截图" class="headerlink" title="浏览器截图"></a>浏览器截图</h4><ol><li>200<ul><li><img src="/2018/08/03/http缓存的攻与防/status_200.png" alt="200"></li></ul></li><li>304 Not Modified<ul><li><img src="/2018/08/03/http缓存的攻与防/status_304.png" alt="304 Not Modified"></li></ul></li><li>200（from cache）/ 200（from member）<ul><li><img src="/2018/08/03/http缓存的攻与防/status_200_cache.png" alt="200（from cache）/ 200（from member） "></li></ul></li></ol><h4 id="强缓、协商缓存流程图"><a href="#强缓、协商缓存流程图" class="headerlink" title="强缓、协商缓存流程图"></a>强缓、协商缓存流程图</h4><p>非完整流程，仅基于各自缓存</p><ul><li><img src="/2018/08/03/http缓存的攻与防/强缓、命中.jpg" alt="200（from disk cache）/ 200（from memory） "></li><li><img src="/2018/08/03/http缓存的攻与防/强缓、未命中.jpg" alt="200（from disk cache）/ 200（from memory） "></li><li><img src="/2018/08/03/http缓存的攻与防/协商、命中.jpg" alt="200（from disk cache）/ 200（from memory） "></li><li><img src="/2018/08/03/http缓存的攻与防/协商、未命中.jpg" alt="200（from disk cache）/ 200（from memory） "></li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th>状态码</th><th>缓存大名</th><th>获取资源</th><th>发送服务器请求</th></tr></thead><tbody><tr><td>200（from disk cache）/ 200（from memory）</td><td>强缓存</td><td>缓存</td><td>否</td></tr><tr><td>304 Not Modified</td><td>协商缓存</td><td>缓存</td><td>是</td></tr></tbody></table><h3 id="完整流程图"><a href="#完整流程图" class="headerlink" title="完整流程图"></a>完整流程图</h3><p><img src="/2018/08/03/http缓存的攻与防/流程图.jpg" alt="流程图"></p><h3 id="几种缓存策略"><a href="#几种缓存策略" class="headerlink" title="几种缓存策略"></a>几种缓存策略</h3><p>存储策略、过期策略、对比策略</p><p><img src="/2018/08/03/http缓存的攻与防/缓存策略.jpg" alt="流程图"></p><h4 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h4><p>_作用_：决定 Http 响应内容是否可缓存到客户端</p><p><code>Cache-Control</code>头里面的以下值，都是来指明响应内容是否可以被客户端存储的</p><ul><li><p>缓存文件数据</p><ul><li><code>Public</code>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li><li><code>Private</code>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li><li><code>no-cache</code>：相当于<code>max-age=0</code>即资源被缓存, 但是缓存立刻过期, 同时下次访问时强制验证资源有效性</li><li><code>max-age</code>：缓存资源, 但是在指定时间(单位为秒)后缓存过期</li></ul></li></ul><ul><li><p>不会在客户端缓存任何响应数据</p><ul><li><code>no-store</code>：禁止游览器缓存数据，每次都会下载完整的资源。</li></ul><p>​</p></li></ul><h4 id="过期策略（新鲜度）"><a href="#过期策略（新鲜度）" class="headerlink" title="过期策略（新鲜度）"></a>过期策略（新鲜度）</h4><p>_作用_：定客户端是否可直接从本地缓存数据中加载数据并展示（否则就发请求到服务端获取）</p><ul><li><code>Expires</code>（<code>http 1.0</code>）：缓存数据有效的绝对时间，告诉客户端到了这个时间点（比照客户端时间点）后本地缓存就作废了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示。</li><li><code>max-age</code>（<code>http 1.1</code>）：优先级高。同时存在的时候，会覆盖掉<code>Expires</code>。</li></ul><p>注：标记不新鲜，不等于没用，见下节：对比策略</p><p>​</p><h4 id="对比策略"><a href="#对比策略" class="headerlink" title="对比策略"></a>对比策略</h4><p>_作用_：服务端根据http报文header，判断客户端缓存数据是否仍有效，进而决定body从客户端读（304）还是服务器给（200）。</p><ul><li>当客户端缓存不新鲜或浏览器刷新后，发起一个http请求，服务器根据request中（<code>If-Modified-Since</code>、<code>If-None-Match</code>）来判断标识是否有效。</li></ul><table><thead><tr><th>request</th><th>response</th><th>描述</th><th>优先级</th></tr></thead><tbody><tr><td>If-Modified-Since</td><td>Last-Modifie</td><td>浏览器资源的最后修改时间（最小粒度是s级的）</td><td>低</td></tr><tr><td>If-None-Match</td><td>ETag</td><td>当前资源在服务器的唯一标识</td><td>高</td></tr></tbody></table><p>为什么会有2个类似作用的字段呢，咱们得从<code>Last-Modifie</code>的缺点来讲：</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)；</li><li>某些文件在秒以下的时间内进行修改</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><p>注：<code>Last-Modifie</code>在某些情况下会触发过期策略，下面会细讲。</p><p>​</p><h4 id="缓存策略三要素汇总图"><a href="#缓存策略三要素汇总图" class="headerlink" title="缓存策略三要素汇总图"></a>缓存策略三要素汇总图</h4><p><img src="/2018/08/03/http缓存的攻与防/缓存策略+header.jpg" alt="流程图"></p><h4 id="考考你"><a href="#考考你" class="headerlink" title="考考你"></a>考考你</h4><p>以下几种情况，三种策略分别是什么？</p><h5 id="考一："><a href="#考一：" class="headerlink" title="考一："></a>考一：</h5><pre><code>HTTP/1.1 200 OK
Cache-Control: no-cache
Content-Type: image/png
Last-Modified: Tue, 08 Nov 2018 06:59:00 GMT
Accept-Ranges: bytes
Date: Thu, 10 Nov 2018 02:48:50 GMT
Content-Length: 3534
</code></pre><p>答：</p><table><thead><tr><th>策略</th><th>缓存策略值</th><th>结果</th></tr></thead><tbody><tr><td>存储策略</td><td>Cache-Control: no-cache</td><td>会被缓存在客户端</td></tr><tr><td>过期策略</td><td>Date: Thu, 10 Nov 2018 02:48:50 GMT</td><td>立即过期，第二次会重新发起http请求</td></tr><tr><td>对比策略</td><td>Last-Modified: Tue, 08 Nov 2018 06:59:00 GMT</td><td>请求request携带该值，和服务器比对，比对成功304，否则200并带body数据</td></tr></tbody></table><h5 id="考二："><a href="#考二：" class="headerlink" title="考二："></a>考二：</h5><pre><code>HTTP/1.1 200 OK
Content-Type: image/png
Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT
Accept-Ranges: bytes
Date: Thu, 10 Nov 2016 02:48:50 GMT
Content-Length: 3534
</code></pre><p>答：</p><p><code>Expires</code>或<code>Cache-Control: max-age</code>都没有在响应头中出现, 并且也没有其它缓存的设置, 那么浏览器默认会采用一个启发式的算法, 通常会取响应头的<code>Date_value - Last-Modified_value</code>值的<code>10%</code>作为缓存时间。</p><table><thead><tr><th>策略</th><th>缓存策略值</th><th>结果</th></tr></thead><tbody><tr><td>存储策略</td><td>Cache-Control: private</td><td>Cache-Control的默认值</td></tr><tr><td>过期策略</td><td>Date +（ Date - Last-Modified） * 10%</td><td>根据计算得到的一个过期时间</td></tr><tr><td>对比策略</td><td>Last-Modified: Tue, 08 Nov 2018 06:59:00 GMT</td><td>请求request携带该值，和服务器比对，比对成功304，否则200并带body数据</td></tr></tbody></table><h4 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h4><ul><li>什么时候会缓存？</li><li>什么时候会强缓存？</li><li>什么时候会协商缓存？</li></ul><h4 id="BF-Cache"><a href="#BF-Cache" class="headerlink" title="BF Cache"></a>BF Cache</h4><p>除了以上缓存外，浏览器还存在一种更强的缓存策略，即在点击浏览器的前进和后退按钮时应用的缓存，称为前进/后退缓存（<code>Backward/Forward Cache</code>），简称<code>BF Cache</code>。</p><ul><li><code>BF Cache</code>表现为 DOM、window、甚至 JavaScript 对象被缓存，以及同步 XHR 也被缓存。 这一现象在移动端浏览器尤为常见。</li><li><code>BF Cache</code> 是一种浏览器优化，HTML 标准并未指定其如何进行缓存，因此缓存行为是与浏览器实现相关的。</li></ul><h2 id="缓存的攻与防"><a href="#缓存的攻与防" class="headerlink" title="缓存的攻与防"></a>缓存的攻与防</h2><h3 id="缓存有什么用"><a href="#缓存有什么用" class="headerlink" title="缓存有什么用"></a>缓存有什么用</h3><p>合理的使用缓存可以极大地提高网站的性能优势，还可以节约带宽从而降低服务器成本。</p><p><img src="/2018/08/03/http缓存的攻与防/cache_Effect.png" alt="作用"></p><h3 id="缓存方案实例："><a href="#缓存方案实例：" class="headerlink" title="缓存方案实例："></a>缓存方案实例：</h3><h4 id="方案一：设置长时间max-age"><a href="#方案一：设置长时间max-age" class="headerlink" title="方案一：设置长时间max-age"></a>方案一：设置长时间<code>max-age</code></h4><pre><code>// 设置缓存时间为1年
Cache-Control: max-age=31536000
</code></pre><p><img src="/2018/08/03/http缓存的攻与防/方案一.jpg" alt="作用"></p><p><img src="/2018/08/03/http缓存的攻与防/方案一 2.jpg" alt="作用"></p><p>在接下来的一年里，客户端再也没有和服务器要过app.js，到期了缓存服务器会把它清扫掉(不算上缓存回收等其他机制)</p><h4 id="方案二：Cache-Control-no-cache-ETag-Last-modified"><a href="#方案二：Cache-Control-no-cache-ETag-Last-modified" class="headerlink" title="方案二：Cache-Control: no-cache + (ETag / Last-modified )"></a>方案二：<code>Cache-Control: no-cache</code> + (<code>ETag</code> / <code>Last-modified</code> )</h4><p><img src="/2018/08/03/http缓存的攻与防/方案二.jpg" alt="作用"></p><p><img src="/2018/08/03/http缓存的攻与防/方案二 2.jpg" alt="作用"></p><h4 id="方案三：Cache-Control-no-store"><a href="#方案三：Cache-Control-no-store" class="headerlink" title="方案三：Cache-Control: no-store"></a>方案三：<code>Cache-Control: no-store</code></h4><p><img src="/2018/08/03/http缓存的攻与防/方案三.jpg" alt="作用"></p><h3 id="攻"><a href="#攻" class="headerlink" title="攻"></a>攻</h3><pre><code>以下几种常见的场景，各适用哪种方案
1. CSS和JS等其他资源
2. HTML等入口文件
3. 内容经常修改但是URL不变的静态资源
4. 权益显示 =》 权益履约，履约完通过浏览器自带的“后退”到“权益显示”页面。
</code></pre><p>答：<br>1.方案一 2.方案二 3.方案二 4.方案三<br>​</p><h3 id="守"><a href="#守" class="headerlink" title="守"></a>守</h3><h4 id="如何避免强缓"><a href="#如何避免强缓" class="headerlink" title="如何避免强缓"></a>如何避免强缓</h4><ol><li>服务端将响应头<code>Cache-control</code>设为<code>no-cache</code>/<code>max-age=0</code>/<code>no-store</code>都可以控制页面不缓存目标资源，这种方式为主流方式；</li><li>服务端将响应头<code>Expires</code>设为一个过去的时间，会保证资源始终从服务器请求；</li><li>HTML META标签和HTTP头信息设置<code>Pragma:no-cache</code>等，这种方式效率不高，且存在浏览器兼容性问题，所以不推荐使用；</li><li>不需要缓存的静态资源增加<code>search</code>参数来当做版本号，更新该版本号会避免浏览器对该资源的缓存。</li></ol><h4 id="如何避免BF-Cache？"><a href="#如何避免BF-Cache？" class="headerlink" title="如何避免BF Cache？"></a>如何避免BF Cache？</h4><ol><li>对HTML文件<code>Cache-control</code>设为<code>no-store</code>可避免BF Cache。（Chrome下同域页面的前进回退仍然会强缓存，目前没有好的解决方案）</li><li>使用<code>onpageshow</code>方法监测<code>event.persisted</code>属性，检测到是从缓存加载时执行<code>reload</code>（桌面浏览器无效，因为<code>persisted</code>始终为<code>false</code>）</li><li>XHR请求可以通过添加一个随机的<code>query</code>来避免BF Cache</li></ol><h2 id="缓存还受什么影响"><a href="#缓存还受什么影响" class="headerlink" title="缓存还受什么影响"></a>缓存还受什么影响</h2><h3 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h3><p><img src="/2018/08/03/http缓存的攻与防/behavior.png" alt="用户行为"><br>实操下来，标红的需要注意，仅chrome和firefox，解析标准也不一致</p><h2 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h2><p>H5的离线缓存 AppCache（Manifest）因为会强制缓存包括HTML文件本身，隔离浏览器与服务器，所以离线化优先级高于浏览器缓存。</p><ol><li>如果html需要的资源，不在Manifest文件类，会报错，可在NETWORK文件中配置*来解决。</li><li>遵循全量缓存的规律。更新appcache会导致所有文件都重新请求</li><li>当次并不生效而是要等到下一次请求才能生效， 当次显示还是采用之前缓存过得文件。JS监听applicationCache.status状态来控制页面是否reload</li></ol><p>html5 app cache 的问题：</p><ol><li>第一次必须联网，在移动网络下首次打开效果非常不理想</li><li>http 头设置会导致 manifest 无法正常更新，见 <a href="http://www.alloyteam.com/2012/01/html5-offline-app-update-problem/" target="_blank" rel="noopener">http://www.alloyteam.com/2012/01/html5-offline-app-update-problem/</a></li><li>Manifest 中缓存文件一旦下载出错，后续的文件将不再下载，抛出错误事件，见：<a href="http://stackoverflow.com/questions/6666513/html5-manifest-caching-error" target="_blank" rel="noopener">http://stackoverflow.com/questions/6666513/html5-manifest-caching-error</a></li><li>Android 系统版本众多，较低版本的浏览器对 manifest 支持不完善</li><li>引用 manifest 的 html 页面本身也会被缓存</li><li>《慎用manifest》一文提到的如：页面的参数传递、manifest 的发布、回滚、下线等问题</li></ol><p>参考文章</p><ul><li>【报文中相关缓存头部解释】<a href="http://louiszhai.github.io/2017/04/07/http-cache/#Cache-Control" target="_blank" rel="noopener">浏览器缓存机制剖析 | louis blog</a></li><li>【发散的，实战型文档】<a href="https://my.oschina.net/liting/blog/425971" target="_blank" rel="noopener">浏览器缓存 - java学者 - 开源中国</a></li><li>【启发式缓存 &amp; 缓存策略3要素】<a href="http://mp.weixin.qq.com/s/uWPls0qrqJKHkHfNLmaenQ" target="_blank" rel="noopener">彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法</a></li><li>【2种缓存：各自流程图】<a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">彻底弄懂HTTP缓存机制及原理 - 木上有水 - 博客园</a></li><li>【2种缓存：各自形象示例说明】<a href="https://segmentfault.com/a/1190000014134828#articleHeader5" target="_blank" rel="noopener">前端静态资源缓存最优解以及max-age的陷阱 - 张亚涛 - SegmentFault 思否</a></li><li>【2种缓存：对比各缓存值】<a href="https://blog.csdn.net/qianqianstd/article/details/75907082" target="_blank" rel="noopener">cache 强缓存 协商缓存 - CSDN博客</a></li><li>【2种缓存：完整流程图】<a href="https://www.cnblogs.com/wonyun/p/5524617.html" target="_blank" rel="noopener">http协商缓存VS强缓存 - wonyun - 博客园</a></li></ul></div><div class="post-toc" id="postToc"><div class="toc-outer"><div class="top-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#http缓存的攻与防"><span class="toc-number">1.</span> <span class="toc-text">http缓存的攻与防</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是缓存？"><span class="toc-number">1.1.</span> <span class="toc-text">什么是缓存？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#几种表现"><span class="toc-number">1.1.1.</span> <span class="toc-text">几种表现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#浏览器截图"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">浏览器截图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#强缓、协商缓存流程图"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">强缓、协商缓存流程图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对比"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完整流程图"><span class="toc-number">1.1.2.</span> <span class="toc-text">完整流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#几种缓存策略"><span class="toc-number">1.1.3.</span> <span class="toc-text">几种缓存策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#存储策略"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">存储策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#过期策略（新鲜度）"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">过期策略（新鲜度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对比策略"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">对比策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存策略三要素汇总图"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">缓存策略三要素汇总图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#考考你"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">考考你</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#考一："><span class="toc-number">1.1.3.5.1.</span> <span class="toc-text">考一：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#考二："><span class="toc-number">1.1.3.5.2.</span> <span class="toc-text">考二：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复习"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">复习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BF-Cache"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">BF Cache</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存的攻与防"><span class="toc-number">1.2.</span> <span class="toc-text">缓存的攻与防</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存有什么用"><span class="toc-number">1.2.1.</span> <span class="toc-text">缓存有什么用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存方案实例："><span class="toc-number">1.2.2.</span> <span class="toc-text">缓存方案实例：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方案一：设置长时间max-age"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">方案一：设置长时间max-age</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方案二：Cache-Control-no-cache-ETag-Last-modified"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">方案二：Cache-Control: no-cache + (ETag / Last-modified )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方案三：Cache-Control-no-store"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">方案三：Cache-Control: no-store</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#攻"><span class="toc-number">1.2.3.</span> <span class="toc-text">攻</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守"><span class="toc-number">1.2.4.</span> <span class="toc-text">守</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何避免强缓"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">如何避免强缓</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何避免BF-Cache？"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">如何避免BF Cache？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存还受什么影响"><span class="toc-number">1.3.</span> <span class="toc-text">缓存还受什么影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用户行为"><span class="toc-number">1.3.1.</span> <span class="toc-text">用户行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他相关"><span class="toc-number">1.4.</span> <span class="toc-text">其他相关</span></a></li></ol></li></ol></div></div></div></article><nav id="pagination"><a href="/2019/09/28/create-react-app/" class="prev"><i class="fa fa-angle-left"></i></a> <a href="/2017/11/17/nth-child使用大全/" class="next"><i class="fa fa-angle-right"></i></a></nav></div></div><script src="/js/scripts.js"></script></div></div><script src="/js/scripts.js"></script></body><!-- rebuild by neat -->